package Graphs;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.* ;
public class MalwareeSpread {
    class Solution {

    public int minMalwareSpread(int[][] graph, int[] initial) {
        // 1. Color each component.
        // colors[node] = the color of this node.

        int N = graph.length;
        int[] colors = new int[N];
        Arrays.fill(colors, -1);
        int C = 0;

        for (int node = 0; node < N; ++node)
            if (colors[node] == -1)
                dfs(graph, colors, node, C++);

        // 2. Size of each color.
        int[] size = new int[C];
        for (int color: colors)
            size[color]++;

        // 3. Find unique colors.
        int[] colorCount = new int[C];
        for (int node: initial)
            colorCount[colors[node]]++;

        // 4. Answer
        int ans = Integer.MAX_VALUE;
        for (int node: initial) {
            int c = colors[node];
            if (colorCount[c] == 1) {
                if (ans == Integer.MAX_VALUE)
                    ans = node;
                else if (size[c] > size[colors[ans]])
                    ans = node;
                else if (size[c] == size[colors[ans]] && node < ans)
                    ans = node;
            }
        }

        if (ans == Integer.MAX_VALUE)
            for (int node: initial)
                ans = Math.min(ans, node);

        return ans;
    }

    public void dfs(int[][] graph, int[] colors, int node, int color) {
        colors[node] = color;
        for (int nei = 0; nei < graph.length; ++nei)
            if (graph[node][nei] == 1 && colors[nei] == -1)
                dfs(graph, colors, nei, color);
    }




    //---------------------------------My wrong understanding Approach--------------------------------
    class Pair{
        int src ;
        int start ; 
        public Pair(int s, int st){
            this.src = s ;
            this.start = st ;
        }
    }
    public int minMalwareSpreadII(int[][] graph, int[] initial) {
        Map<Integer , List<Integer>> adjList = new HashMap<>();
        int n = graph.length; 

        for(int i = 0 ; i < n ; i++){
            adjList.putIfAbsent(i , new ArrayList<>());
            for(int j = 0 ; j < n ; j++){
                if(graph[i][j] == 1 && i != j){
                    adjList.get(i).add(j);
                }
            }
        }
        Queue<Pair> q = new LinkedList<>();
        for(Integer malware : initial){
            q.add(new Pair(malware , malware));
        }
        boolean[] visited = new boolean[n];
        Map<Integer , Integer> map = new HashMap<>();
        while(!q.isEmpty()){
            int size = q.size();
            for(int i = 0 ; i < size ; i++){
                Pair curr = q.poll();
                int src = curr.src ; 
                int start = curr.start ;
                for(Integer neighbor : adjList.get(src)){
                    if(!visited[neighbor]){
                        visited[neighbor] = true ;
                        q.add(new Pair(neighbor , start));
                        map.put(start , map.getOrDefault(start , 0)+1);
                    }
                }
            }
        }
        int maxi = Integer.MIN_VALUE ; 
        int node = Integer.MAX_VALUE  ;
        for(Integer key : map.keySet()){
            if(maxi < map.get(key) || (map.get(key) == maxi && key < node)){
                maxi = map.get(key);
                node = key ;
            }
        }
        return node ;
    }
}
}
